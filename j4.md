## #1
- Explain why the following class declaration is not possible in Java.

You cannot extend multiple classes in Java.
- What are the limitations of the extends key word?

You can only extend one class.
- How can you accomplish this inheritance structure task in Java?

You can mimic this by implementing multiple interfaces.

## #2
In an abstract class, you cannot instanciate an object. A class can only inherit one abstract class, but an interface can inherit multiple interfaces, and a class can also implement multiple interfaces.

## #3
```Java
public interface Stack {
   public void push(int v);
   public int pop();
   public int peek();
}

public interface Queue {
   public void enqueue(int v);
   public int dequeue();
   public int peek();
}

public class LinkedList implements Stack, Queue {
  public LinkedList() {/*...*/}
  public void addToFront(int v) {/*...*/}
  public int rmFromFront() {/*...*/}
  public void addToBack(int v) {/*...*/}
  public void rmFromBack() {/*...*/}
  
  //FINISH HERE
   public void push(int v) {
      addToFront(v);   
   }
   public int pop() {
      return rmFromFront();
   }
   public void peek() {
      int front = rmFromFront();
      addToFront(front);
      return front;
   }
   public void enqueue(int v) {
       addToFront(V);
   }
   public int dequeue() {
       rmFromBack();
   }

}
```

## #4

```Java
public interface Stack<T> {
   public void push(T v);
   public T pop();
   public T peek();
}

public interface Queue<T> {
   public void enqueue(T v);
   public T dequeue();
   public T peek();
}

public class LinkedList implements Stack, Queue {
  public LinkedList() {/*...*/}
  public void addToFront(int v) {/*...*/}
  public int rmFromFront() {/*...*/}
  public void addToBack(int v) {/*...*/}
  public void rmFromBack() {/*...*/}
  
   public void push(T v) {
    addToFront(V);
  }
  public T pop(){
    return rmFromFront();
  }
  public T peek() {
    T front = rmFromFront();
    addToFront(front);
    return front;
  }
  public void enqueue(T v) {
    addToFront(V);
  }
  public T dequeue() {
    rmFromBack();
  }
}
```
## #5
```Java
import java.util.HashMap;

public class TestHashMap {

    public static void main (String[] argv) {
        // Create a new hashmap.
        HashMap<String, String> fabFour = new HashMap<String, String>();

        // Insert four key and value pairs.
        fabFour.put("John", "John Lennon");
        fabFour.put("Paul", "Paul McCartney");
        fabFour.put("George", "George Harrison");
        fabFour.put("Ringo", "Ringo Star");

        // Use a key to retrieve a value.
        String fullName = fabFour.get("Ringo");

        // Prints "Ringo Star"
        System.out.println(fullName);
    }
}
```
## #6
```Java
 public static void main(final String args[]) {
        Shelf favorite_words = new Shelf();
        favorite_words = shelfBuilder();
        favorite_words.addItem("Zoetrope");
        favorite_words.addItem("Succinct");
        //...        
        String s = (String)favorite_words.getItem(1);
        System.out.println(s);
    }
```
## #7
```Java
import java.util.ArrayList;
import java.util.List;

public class Shelf<T> {
    private List<T> shelfItems;

    private String shelfName;

    public Shelf(String shelfName) {
        this.shelfName = shelfName;
        shelfItems = new ArrayList<T>();
    }

    public int addItem(T item) {
        shelfItems.add(item);
        return shelfItems.size();
    }

    public void printShelf() {
        System.out.print(shelfName + ": ");
        for(T item: shelfItems) {
            System.out.print(item.toString() + " ");
        }
        System.out.println();
    }
}
public class TestShelf {
    public static void main(final String args[]) {

        // TODO: Create a shelf to store Shakespeare character names:
        //       Hamlet, Othello, Cordelia, and Juliet
        // TODO: Then print the shelf.
         Shelf<T> shakespeare = new Shelf<T>("Shakespeare Characters");
         T hamlet = new T("Hamlet");
         T othello = new T("Othello");
         T cordelia = new T("Cordelia");
         T juliet = new T("Juliet");
         shakespeare.addItem(hamlet);
         shakespeare.addItem(othello);
         shakespeare.addItem(cordelia);
         shakespeare.addItem(juliet);
         shakespeare.printShelf();

        // TODO: Create a shelf to store famous integers:
        //       13, 23, 42, 1729,
        // TODO: Then print the shelf.
         Shelf<T> famousIntegers = new Shelf<T>("Famous Integers");
         T thirteen = new T(13);
         T twentyThree = new T(23);
         T fourtyTwo = new T(42);
         T thousand = new T(1729);
         famousIntegers.addItem(thirteen);
         famousIntegers.addItem(twentyThree);
         famousIntegers.addItem(fourtyTwo);
         famousIntegers.addItem(thousand);
         famousIntegers.printShelf();

    }
}
```

## #8
```Java
public class LinkedList {
   private class Node {
      int data;
      Node next;
   }
   Node head;

   void add(int data);
   int get(int idx);
   //...   
public class TestingLinkedList {
  public class static main(String args[]) {
     LinkedList ll = new LinkedList();
     
     for(int i = 0; i < 100000; i++){
         ll.add(i * 3);
     }
     
     for(int i = 0; i < 100000; i++){
         System.out.println("" + ll.get(i)); //<-- MARK
     }
  }
}
```
This for loop goes through 100000 elements twice. making the time complexity O(200000), which is extremely inefficient. The line with mark is calling the get function with every i, meaning the complexity gets worse as the get function adds additional calls and lines of code to run.

## #9
Implementing the iterable interface allows an iterator to be returned, which can parse the list itself under the hood instead of ruining the efficiency of the program by manually parsing through 200000 elements. 

## #10
Comparable<T> implements a single method, compareTo(T t). When comparing two variables, this interface works in comparing variables of any type because of it's generic type T. It saves time to just implement the interface instead of individually writing different implementations of compareTo().

## #11

```Java
Name: Lamborghini Top Speed: 225
Name: Porsche Top Speed: 202
Name: Mustang Top Speed: 144
Name: Jeep Top Speed: 110
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Car implements Comparable<Car> {
    public static void main(String[] args) {
        List<Car> carsList = new ArrayList<>();
        carsList.add(new Car("Porsche", 202));
        carsList.add(new Car("Jeep", 110));
        carsList.add(new Car("Mustang", 144));
        carsList.add(new Car("Lamborghini", 225));

        Collections.sort(carsList);
        for(Car car : carsList) {
            System.out.println("Name: " + car.getName() + " Top Speed: " + car.getTopSpeed());
        }
    }
    private String name;
    private Integer topSpeed;

    public Car(String name, Integer topSpeed) {
        this.name = name;
        this.topSpeed = topSpeed;
    }

    public String getName() {
        return name;
    }

    public Integer getTopSpeed() {
        return topSpeed;
    }

    // TODO: Complete the Car class by adding the compareTo method
    //       needed to correctly implement Comparable<Car>.

   public int compareTo(Car other) {
      //ts = this speed, os = other speed
      int ts = this.getTopSpeed();
      int os = other.getTopSpeed();
      if(ts < os) {
         return -1;
      }
      else if (ts > os) {
         return 1;
      }
      else {
         return 0;
      }
}

}
```
